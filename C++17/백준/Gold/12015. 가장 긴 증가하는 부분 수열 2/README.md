# [Gold II] 가장 긴 증가하는 부분 수열 2 - 12015 

[문제 링크](https://www.acmicpc.net/problem/12015) 

### 성능 요약

메모리: 8292 KB, 시간: 148 ms

### 분류

이분 탐색, 가장 긴 증가하는 부분 수열 문제

### 제출 일자

2025년 5월 24일 09:37:22

# 📝 문제 소개

## 문제

---

수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {**10**, **20**, 10, **30**, 20, **50**} 이고, 길이는 4이다.

## 입력

---

첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 Aᵢ가 주어진다. (1 ≤ Aᵢ ≤ 1,000,000)

## 출력

---

첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.

## 제한

---

# 🧩 풀이

이 문제는 **LIS (Longest Increasing Subsequence)** 문제지만, 수열의 길이가 **최대 1,000,000**이기 때문에 O(N**²**) 방식으로는 해결할 수 없다.

문제 풀이의 핵심은 **이분 탐색**을 활용하여 LIS의 길이를 구할 수 있는 **배열**을 만드는 것이다.

- LIS의 실제 수열을 만들 필요는 없고 **길이만 구하면** 되므로 임의의 LIS 후보 배열(`lis`)을 유지한다.
- 수열의 각 원소를 확인하면서, `lis`에 다음 중 하나를  수행한다:
    1. 현재 원소가 `lis`의 마지막 원소보다 크면 → `lis.push_back()`
    2. 그렇지 않으면 → `lower_bound`를 사용해 적절한 위치를 찾아 **값을 덮어쓴다**

이 방법은 수열이 오름차순을 유지하면서 **가장 작은 값으로만 채워지도록 하여**, 나중에 더 많은 값을 붙일 수 있게 한다.

시간복잡도는 **O(N log N)** → N ≤ 1,000,000일 때도 충분히 통과 가능

# [Gold III] 두 배열의 합 - 2143 

[문제 링크](https://www.acmicpc.net/problem/2143) 

### 성능 요약

메모리: 14456 KB, 시간: 132 ms

### 분류

자료 구조, 이분 탐색, 집합과 맵, 누적 합, 해시를 사용한 집합과 맵

### 제출 일자

2025년 5월 20일 19:53:44

# 📝 문제 소개

## 문제

한 배열 A[1], A[2], …, A[n]에 대해서, 부 배열은 A[i], A[i+1], …, A[j-1], A[j] (단, 1 ≤ i ≤ j ≤ n)을 말한다. 이러한 부 배열의 합은 A[i]+…+A[j]를 의미한다. 각 원소가 정수인 두 배열 A[1], …, A[n]과 B[1], …, B[m]이 주어졌을 때, A의 부 배열의 합에 B의 부 배열의 합을 더해서 T가 되는 모든 부 배열 쌍의 개수를 구하는 프로그램을 작성하시오.

예를 들어 A = {1, 3, 1, 2}, B = {1, 3, 2}, T=5인 경우, 부 배열 쌍의 개수는 다음의 7가지 경우가 있다.

```
T(=5) = A[1] + B[1] + B[2]
      = A[1] + A[2] + B[1]
      = A[2] + B[3]
      = A[2] + A[3] + B[1]
      = A[3] + B[1] + B[2]
      = A[3] + A[4] + B[3]
      = A[4] + B[2]
```

## 입력

첫째 줄에 T(-1,000,000,000 ≤ T ≤ 1,000,000,000)가 주어진다. 다음 줄에는 n(1 ≤ n ≤ 1,000)이 주어지고, 그 다음 줄에 n개의 정수로 A[1], …, A[n]이 주어진다. 다음 줄에는 m(1 ≤ m ≤ 1,000)이 주어지고, 그 다음 줄에 m개의 정수로 B[1], …, B[m]이 주어진다. 각각의 배열 원소는 절댓값이 1,000,000을 넘지 않는 정수이다.

## 출력

첫째 줄에 답을 출력한다. 가능한 경우가 한 가지도 없을 경우에는 0을 출력한다.

---

# 🧩 풀이

문제에서 요구하는 건 **A의 부분합 + B의 부분합 = T**를 만족하는 경우의 수이다.

단순히 모든 부분 배열을 구해서 이중 반복문으로 합치는 방식은 시간초과가 발생하기 때문에 다음과 같은 방법을 사용해야 한다.

1. A와 B의 모든 **연속 부분 배열의 합**을 각각 구하여 벡터에 저장한다.
2. B의 부분합 배열을 **정렬**한 뒤, `lower_bound`와 `upper_bound`를 사용해 `T - a_sum[i]` 값이 몇 번 등장하는지 계산한다.
3. 이 과정을 모든 A의 부분합에 대해 반복하여 부 배열 쌍의 개수를 구한다.

## 시간 복잡도

- A의 부분합 구하기: O(N²)
- B의 부분합 구하기: O(M²)
- B의 부분합 정렬: O(M² log M)
- 이진 탐색 수행: O(N² log M)

전체 시간 복잡도는 **O(N² log M + N² log M)** 이지만, N과 M은 1000 이하의 정수이므로 제한 시간 내에 해결할 수 있다.
